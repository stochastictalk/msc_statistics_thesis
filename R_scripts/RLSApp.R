library(shiny)
rm(list=ls())
set.seed(1)

T_ <- 100
sigma2 <- 1
beta_sd <- sqrt(2) # 'Easier' problem the larger beta_sd/sigma2
x <- matrix(rnorm(T_), nrow=T_) # Generate data a priori
X <- matrix(x, nrow=T_) # because I am lazy
beta <- cumsum(rnorm(T_, sd=beta_sd)) # dummy true parameter walk
y <- x*beta + rnorm(T_, mean=0, sd=sigma2)
y <- matrix(y, nrow=T_)

# Bayesian Linear Regression
# Specify prior
mu_0 <- matrix(c(0), nrow=1) # mu_0 
Sigma_0 <- 100*matrix(c(1), nrow=1, ncol=1) # sigma2 Lambda_0^-1
Lambda_0 <- solve(Sigma_0/sigma2)

# Specify parameter noise
# V_w = matrix(c(0, 0, 0, 0), nrow = 2) # assume no noise (fixed parameter)
V_w = matrix((beta_sd^2)*c(1), nrow=1, ncol=1) # modeled noise in regression parameter between time steps

# perform first regression step
Lambda_0 = solve(Sigma_0/sigma2)
X_t <- X[1, , drop=F]
y_t <- y[1, drop=F]
mu_1 <- solve((t(X_t) %*% X_t) + Lambda_0) %*% (Lambda_0 %*% mu_0 + t(X_t) %*% y_t)
Lambda_1 <- (t(X_t) %*% X_t) + Lambda_0
Sigma_1 <- sigma2*solve(Lambda_1)

# update Lambda_1 to account for parameter uncertainty
Lambda_1 <- solve((Sigma_1 + V_w)/sigma2)
betaMu <- matrix(rep(NA,T_), nrow=T_)
betaSD <- matrix(rep(NA, T_), nrow=T_)
betaMu[1] <- mu_1
betaSD[1] <- sqrt(Sigma_1)

for (t in 2:T_) {
  X_t <- X[t, , drop=F]
  y_t <- y[t, drop=F]
  mu_1 <- solve((t(X_t) %*% X_t) + Lambda_1) %*% (Lambda_1 %*% mu_1 + t(X_t) %*% y_t)
  Lambda_1 <- (t(X_t) %*% X_t) + Lambda_1
  Sigma_1 <- sigma2*solve(Lambda_1)
  
  # update Lambda_1 to account for parameter uncertainty
  Lambda_1 <- solve((1/sigma2)*(Sigma_1 + V_w))
  
  # record mean and sd
  betaMu[t] <- mu_1
  betaSD[t] <- sqrt(Sigma_1)
}

# Define UI for slider demo app ----
ui <- fluidPage(
  
  # App title ----
  titlePanel(title = h1("Streaming Bayesian Linear Regression", align='center')),
  
  # Sidebar layout with input and output definitions ----
  sidebarLayout( # takes two arguments, the outputs of sidebarPanel and mainPanel
    # Sidebar to demonstrate various slider options ----
    sidebarPanel(
      h4('Data Process Information'),
      withMathJax(),
      sprintf('The x-values \\(x_t\\) are a sequence of independent samples from the standard normal distribution.'),
      sprintf('$$ x_t \\sim \\mathcal{N}(0, 1)$$'),
      sprintf('The hidden parameter values are generated by a Brownian motion of variance \\(\\sqrt{2}\\).'),
      sprintf('$$ \\{\\beta_t\\} \\sim B(0, 2) $$'),
      sprintf('The y-values are generated by the expression'),
      sprintf('$$ y_t = \\beta_t x_t + \\epsilon_t $$'),
      sprintf('where the \\(\\epsilon_t\\) are independently sampled from the univariate standard normal distribution.'),
      h4('Model Information'),
      p('The regression model consists of a recursively updating Bayesian model that is correctly specified.'),
      sliderInput(inputId="animation", # handle to the widget
                  label = 'Animation iteration:', # display label of widget
                  min = 1, max = T_,
                  value = 1, step = 1,
                  animate = animationOptions(interval = 300, loop = TRUE)),
      width=3
    ),
    
    # Main panel for displaying outputs ----
    mainPanel(
      plotOutput(outputId = 'scatterPlot'),
      plotOutput(outputId = 'parameterPlot'),
      width = 9
    )
  )
)

# Define server logic for slider examples ----
server <- function(input, output) {
  
  output$scatterPlot <- renderPlot(expr = {
    par(mar = c(5, 5, 1, 1))
    lambda <- 0.8
    fading <- sapply(1:input$animation, FUN = function(x) {lambda^(input$animation-x)})
    plot(x[1:input$animation], y[1:input$animation], type='p', pch=21,
         bg=rgb(0*fading, 0*fading, 0*fading, 1*fading), lwd=0,
         xlim = c(min(x), max(x)), ylim = c(quantile(y,0.2), quantile(y,0.8)),
         xlab='x-value', ylab='y-value', cex.axis=1.5, cex.lab=1.5)
    abline(coef=c(0, beta[input$animation]))
    abline(coef=c(0, betaMu[input$animation]), col='red')
    abline(coef=c(0, betaMu[input$animation]+betaSD[1:input$animation]*1.95), col='red', lty=2)
    abline(coef=c(0, betaMu[input$animation]-betaSD[1:input$animation]*1.95), col='red', lty=2)
  })
  output$parameterPlot <- renderPlot(expr = {
    par(mar = c(5, 5, 1, 1))
    plot(beta[1:input$animation], type='p',
         xlim=c(1, T_),
         ylim=c(min(beta), max(beta)),
         bg='black', pch=21, xlab='Iteration', ylab='Value', cex.axis=1.5, cex.lab=1.5)
    points(betaMu[1:input$animation], col='red')
    lines( (betaMu[1:input$animation] + betaSD[1:input$animation]*1.95), col='red')
    lines( (betaMu[1:input$animation] - betaSD[1:input$animation]*1.95) , col='red')
    legend('topright', legend=c('Hidden value', 'Predicted value with 95% credible interval'),
           fill=c('black', 'red'), cex=1.25)
  })
  
}

# Create Shiny app ----
shinyApp(ui, server)